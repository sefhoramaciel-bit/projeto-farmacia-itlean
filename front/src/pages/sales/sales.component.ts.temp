import { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';
import { ApiService } from '../../services/api.service';
import { SalesService } from '../../services/sales.service';
import { NotificationService } from '../../services/notification.service';
import { Customer, Medicine, CartItem, Sale, SaleRequest } from '../../models/types';
import { LogService } from '../../services/log.service';

@Component({
  selector: 'app-sales',
  templateUrl: './sales.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [CommonModule, ReactiveFormsModule],
})
export class SalesComponent {
  private apiService = inject(ApiService);
  private salesService = inject(SalesService);
  private notificationService = inject(NotificationService);
  private logService = inject(LogService);
  // Fix: Explicitly type FormBuilder to resolve issues where its methods were not recognized and to fix cascading type errors.
  private fb: FormBuilder = inject(FormBuilder);

  customer = signal<Customer | null>(null);
  cart = signal<CartItem[]>([]);
  searchResults = signal<Medicine[]>([]);
  isSearching = signal(false);

  cpfForm = this.fb.group({
    cpf: ['', [Validators.required, Validators.pattern(/^\d{3}\.\d{3}\.\d{3}\-\d{2}$/)]]
  });

  // Fix: Explicitly type the form control to avoid 'unknown' type in valueChanges stream.
  searchControl = this.fb.control<string>('');

  total = computed(() => {
    return this.cart().reduce((acc, item) => acc + item.preco * item.quantidadeCarrinho, 0);
  });
  
  constructor() {
    this.searchControl.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      // Fix: Explicitly type the 'term' parameter to resolve 'unknown' type from valueChanges stream.
      switchMap((term: string | null) => {
        if (!term || term.length < 2) {
          this.searchResults.set([]);
          return [];
        }
        this.isSearching.set(true);
        return this.apiService.searchMedicines(term);
      })
    ).subscribe(results => {
      // Ordena alfabeticamente por nome
      const sortedResults = results.sort((a, b) => a.nome.localeCompare(b.nome, 'pt-BR', { sensitivity: 'base' }));
      this.searchResults.set(sortedResults);
      this.isSearching.set(false);
    });
  }

  findCustomer() {
    if (this.cpfForm.invalid) {
      this.notificationService.error('CPF InvÃ¡lido', 'Por favor, insira um CPF vÃ¡lido no formato 000.000.000-00.');
      return;
    }
    const cpf = this.cpfForm.value.cpf!;
    this.apiService.findCustomerByCpf(cpf).subscribe(cust => {
      if (cust) {
        this.customer.set(cust);
        this.notificationService.success('Cliente Encontrado', `Iniciando venda para ${cust.nome}.`);
      } else {
        this.notificationService.error('Cliente nÃ£o Encontrado', 'Nenhum cliente com este CPF. Cadastre-o primeiro.');
      }
    });
  }

  addToCart(medicine: Medicine) {
    const existingItem = this.cart().find(item => item.id === medicine.id);
    if (existingItem) {
      this.updateQuantity(existingItem.id, existingItem.quantidadeCarrinho + 1);
    } else {
      if (medicine.quantidadeEstoque > 0) {
        const newItem: CartItem = { ...medicine, quantidadeCarrinho: 1 };
        this.cart.update(currentCart => [...currentCart, newItem]);
      } else {
        this.notificationService.error('Sem Estoque', `${medicine.nome} nÃ£o estÃ¡ disponÃ­vel em estoque.`);
      }
    }
  }

  updateQuantity(medicineId: string, newQuantity: number) {
    this.cart.update(currentCart => 
      currentCart.map(item => {
        if (item.id === medicineId) {
          if (newQuantity <= 0) return null; // Marked for removal
          if (newQuantity > item.quantidadeEstoque) {
            this.notificationService.error('Estoque Insuficiente', `Apenas ${item.quantidadeEstoque} unidades de ${item.nome} disponÃ­veis.`);
            return { ...item, quantidadeCarrinho: item.quantidadeEstoque };
          }
          return { ...item, quantidadeCarrinho: newQuantity };
        }
        return item;
      }).filter(item => item !== null) as CartItem[]
    );
  }

  removeFromCart(medicineId: string) {
    this.cart.update(currentCart => currentCart.filter(item => item.id !== medicineId));
  }

  finalizeSale() {
    if (this.cart().length === 0) {
      this.notificationService.error('Carrinho Vazio', 'Adicione pelo menos um item para finalizar a venda.');
      return;
    }

    const sale: SaleRequest = {
      clienteId: this.customer()!.id,
      itens: this.cart().map(item => ({
        medicamentoId: item.id,
        quantidade: item.quantidadeCarrinho,
      })),
    };
    
    this.salesService.create(sale).subscribe({
      next: (res) => {
        this.notificationService.success('Venda Finalizada!', `Venda #${res.id} registrada com sucesso.`);
        this.logService.logAction('CriaÃ§Ã£o', 'Venda', `Venda #${res.id} finalizada para o cliente '${res.clienteNome}' no valor total de R$ ${res.valorTotal.toFixed(2)}.`);
        this.resetSale();
      },
      error: (err) => {
        const errorMessage = err?.error?.error || 'NÃ£o foi possÃ­vel registrar a venda. Tente novamente.';
        this.notificationService.error('Erro na Venda', errorMessage);
      }
    });
  }

  resetSale() {
    this.customer.set(null);
    this.cart.set([]);
    this.searchResults.set([]);
    this.cpfForm.reset();
    this.searchControl.reset();
  }

  formatCpf(event: Event) {
    const input = event.target as HTMLInputElement;
    let value = input.value.replace(/\D/g, '');
    if (value.length > 11) value = value.slice(0, 11);

    if (value.length > 9) {
      value = value.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
    } else if (value.length > 6) {
      value = value.replace(/(\d{3})(\d{3})(\d{0,3})/, '$1.$2.$3');
    } else if (value.length > 3) {
      value = value.replace(/(\d{3})(\d{0,3})/, '$1.$2');
    }
    this.cpfForm.controls.cpf.setValue(value, { emitEvent: false });
  }
}
